Repository Content Dump
=======================
Directory: /Users/jckwind/Documents/Hermes
Generated: Fri May 10 17:34:07 EDT 2024

##
Full Directory Tree
#
/Users/jckwind/Documents/Hermes
├── Hermes_05-24_17-34.dump.txt
├── README.md
├── contacts.json
├── requirements.txt
├── schema.txt
└── src
    ├── components
    │   ├── button.py
    │   └── toolbar.py
    ├── gui.py
    └── text_collector.py

3 directories, 9 files

##
File Name: .cursorignore
#
"""
# Add directories or file patterns to ignore during indexing (e.g. foo/ or *.csv)
contacts.json
README.md


"""

##
##
File Name: requirements.txt
#
"""
cryptography
google-generativeai
pyinstaller
"""

##
##
File Name: README.md
#
"""
# Hermes - Encrypted iMessage Extractor and Viewer

## Overview
Hermes is a tool designed to securely extract and view iMessages from macOS devices. 

## Features
- **GUI Viewer**: View messages through a user-friendly interface.

## Installation

### Prerequisites
- Python 3.x
- Access to macOS with iMessages

### Setup
1. Clone this repository:

`git clone https://github.com/yourusername/Hermes.git`

2. Navigate to the Hermes directory:
    `cd Hermes`

3. Install required Python packages:

`pip install -r requirements.txt`


## Usage
Run the `gui.py` from the src directory:

`python src/gui.py`


## License
This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

"""

##
##
File Name: schema.txt
#
"""
Schema for chat_message_join:
(0, 'chat_id', 'INTEGER', 0, None, 1)
(1, 'message_id', 'INTEGER', 0, None, 2)
(2, 'message_date', 'INTEGER', 0, '0', 0)
Schema for chat_handle_join:
(0, 'chat_id', 'INTEGER', 0, None, 0)
(1, 'handle_id', 'INTEGER', 0, None, 0)
Schema for message:
(0, 'ROWID', 'INTEGER', 0, None, 1)
(1, 'guid', 'TEXT', 1, None, 0)
(2, 'text', 'TEXT', 0, None, 0)
(3, 'replace', 'INTEGER', 0, '0', 0)
(4, 'service_center', 'TEXT', 0, None, 0)
(5, 'handle_id', 'INTEGER', 0, '0', 0)
(6, 'subject', 'TEXT', 0, None, 0)
(7, 'country', 'TEXT', 0, None, 0)
(8, 'attributedBody', 'BLOB', 0, None, 0)
(9, 'version', 'INTEGER', 0, '0', 0)
(10, 'type', 'INTEGER', 0, '0', 0)
(11, 'service', 'TEXT', 0, None, 0)
(12, 'account', 'TEXT', 0, None, 0)
(13, 'account_guid', 'TEXT', 0, None, 0)
(14, 'error', 'INTEGER', 0, '0', 0)
(15, 'date', 'INTEGER', 0, None, 0)
(16, 'date_read', 'INTEGER', 0, None, 0)
(17, 'date_delivered', 'INTEGER', 0, None, 0)
(18, 'is_delivered', 'INTEGER', 0, '0', 0)
(19, 'is_finished', 'INTEGER', 0, '0', 0)
(20, 'is_emote', 'INTEGER', 0, '0', 0)
(21, 'is_from_me', 'INTEGER', 0, '0', 0)
(22, 'is_empty', 'INTEGER', 0, '0', 0)
(23, 'is_delayed', 'INTEGER', 0, '0', 0)
(24, 'is_auto_reply', 'INTEGER', 0, '0', 0)
(25, 'is_prepared', 'INTEGER', 0, '0', 0)
(26, 'is_read', 'INTEGER', 0, '0', 0)
(27, 'is_system_message', 'INTEGER', 0, '0', 0)
(28, 'is_sent', 'INTEGER', 0, '0', 0)
(29, 'has_dd_results', 'INTEGER', 0, '0', 0)
(30, 'is_service_message', 'INTEGER', 0, '0', 0)
(31, 'is_forward', 'INTEGER', 0, '0', 0)
(32, 'was_downgraded', 'INTEGER', 0, '0', 0)
(33, 'is_archive', 'INTEGER', 0, '0', 0)
(34, 'cache_has_attachments', 'INTEGER', 0, '0', 0)
(35, 'cache_roomnames', 'TEXT', 0, None, 0)
(36, 'was_data_detected', 'INTEGER', 0, '0', 0)
(37, 'was_deduplicated', 'INTEGER', 0, '0', 0)
(38, 'is_audio_message', 'INTEGER', 0, '0', 0)
(39, 'is_played', 'INTEGER', 0, '0', 0)
(40, 'date_played', 'INTEGER', 0, None, 0)
(41, 'item_type', 'INTEGER', 0, '0', 0)
(42, 'other_handle', 'INTEGER', 0, '0', 0)
(43, 'group_title', 'TEXT', 0, None, 0)
(44, 'group_action_type', 'INTEGER', 0, '0', 0)
(45, 'share_status', 'INTEGER', 0, '0', 0)
(46, 'share_direction', 'INTEGER', 0, '0', 0)
(47, 'is_expirable', 'INTEGER', 0, '0', 0)
(48, 'expire_state', 'INTEGER', 0, '0', 0)
(49, 'message_action_type', 'INTEGER', 0, '0', 0)
(50, 'message_source', 'INTEGER', 0, '0', 0)
(51, 'associated_message_guid', 'TEXT', 0, None, 0)
(52, 'associated_message_type', 'INTEGER', 0, '0', 0)
(53, 'balloon_bundle_id', 'TEXT', 0, None, 0)
(54, 'payload_data', 'BLOB', 0, None, 0)
(55, 'expressive_send_style_id', 'TEXT', 0, None, 0)
(56, 'associated_message_range_location', 'INTEGER', 0, '0', 0)
(57, 'associated_message_range_length', 'INTEGER', 0, '0', 0)
(58, 'time_expressive_send_played', 'INTEGER', 0, None, 0)
(59, 'message_summary_info', 'BLOB', 0, None, 0)
(60, 'ck_sync_state', 'INTEGER', 0, '0', 0)
(61, 'ck_record_id', 'TEXT', 0, None, 0)
(62, 'ck_record_change_tag', 'TEXT', 0, None, 0)
(63, 'destination_caller_id', 'TEXT', 0, None, 0)
(64, 'is_corrupt', 'INTEGER', 0, '0', 0)
(65, 'reply_to_guid', 'TEXT', 0, None, 0)
(66, 'sort_id', 'INTEGER', 0, None, 0)
(67, 'is_spam', 'INTEGER', 0, '0', 0)
(68, 'has_unseen_mention', 'INTEGER', 0, '0', 0)
(69, 'thread_originator_guid', 'TEXT', 0, None, 0)
(70, 'thread_originator_part', 'TEXT', 0, None, 0)
(71, 'syndication_ranges', 'TEXT', 0, None, 0)
(72, 'synced_syndication_ranges', 'TEXT', 0, None, 0)
(73, 'was_delivered_quietly', 'INTEGER', 0, '0', 0)
(74, 'did_notify_recipient', 'INTEGER', 0, '0', 0)
(75, 'date_retracted', 'INTEGER', 0, None, 0)
(76, 'date_edited', 'INTEGER', 0, None, 0)
(77, 'was_detonated', 'INTEGER', 0, '0', 0)
(78, 'part_count', 'INTEGER', 0, None, 0)
(79, 'is_stewie', 'INTEGER', 0, '0', 0)
(80, 'is_kt_verified', 'INTEGER', 0, '0', 0)
(81, 'is_sos', 'INTEGER', 0, '0', 0)
(82, 'is_critical', 'INTEGER', 0, '0', 0)
(83, 'bia_reference_id', 'TEXT', 0, 'NULL', 0)
(84, 'fallback_hash', 'TEXT', 0, 'NULL', 0)
Schema for chat:
(0, 'ROWID', 'INTEGER', 0, None, 1)
(1, 'guid', 'TEXT', 1, None, 0)
(2, 'style', 'INTEGER', 0, None, 0)
(3, 'state', 'INTEGER', 0, None, 0)
(4, 'account_id', 'TEXT', 0, None, 0)
(5, 'properties', 'BLOB', 0, None, 0)
(6, 'chat_identifier', 'TEXT', 0, None, 0)
(7, 'service_name', 'TEXT', 0, None, 0)
(8, 'room_name', 'TEXT', 0, None, 0)
(9, 'account_login', 'TEXT', 0, None, 0)
(10, 'is_archived', 'INTEGER', 0, '0', 0)
(11, 'last_addressed_handle', 'TEXT', 0, None, 0)
(12, 'display_name', 'TEXT', 0, None, 0)
(13, 'group_id', 'TEXT', 0, None, 0)
(14, 'is_filtered', 'INTEGER', 0, '0', 0)
(15, 'successful_query', 'INTEGER', 0, None, 0)
(16, 'engram_id', 'TEXT', 0, None, 0)
(17, 'server_change_token', 'TEXT', 0, None, 0)
(18, 'ck_sync_state', 'INTEGER', 0, '0', 0)
(19, 'original_group_id', 'TEXT', 0, None, 0)
(20, 'last_read_message_timestamp', 'INTEGER', 0, '0', 0)
(21, 'cloudkit_record_id', 'TEXT', 0, None, 0)
(22, 'last_addressed_sim_id', 'TEXT', 0, None, 0)
(23, 'is_blackholed', 'INTEGER', 0, '0', 0)
(24, 'syndication_date', 'INTEGER', 0, '0', 0)
(25, 'syndication_type', 'INTEGER', 0, '0', 0)
(26, 'is_recovered', 'INTEGER', 0, '0', 0)
(27, 'is_deleting_incoming_messages', 'INTEGER', 0, '0', 0)
Schema for handle:
(0, 'ROWID', 'INTEGER', 0, None, 1)
(1, 'id', 'TEXT', 1, None, 0)
(2, 'country', 'TEXT', 0, None, 0)
(3, 'service', 'TEXT', 1, None, 0)
(4, 'uncanonicalized_id', 'TEXT', 0, None, 0)
(5, 'person_centric_id', 'TEXT', 0, None, 0)
"""

##
##
File Name: contacts.json
#
"""
{
    "+13024386694": "Nick",
    "+17037250244": "Chris",
    "+14438785968": "Ishaan",
    "+17033428630": "Paul",
    "+17037986291": "Kate Landlord",
    "+14344098567": "Gibbs (Intern)"
}
"""

##
##
File Name: text_collector.py
#
"""
import sqlite3
import datetime
import json
from typing import List, Dict, Union

class TextCollector:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.conn = self._connect_database()

    def _connect_database(self) -> Union[sqlite3.Connection, None]:
        try:
            connection = sqlite3.connect(self.db_path)
            return connection
        except sqlite3.OperationalError as error:
            print(f"Failed to connect to the database at {self.db_path}. Error: {error}")
            return None

    def get_all_chat_ids_with_labels(self) -> List[tuple]:
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT cmj.chat_id, c.display_name, c.chat_identifier
            FROM chat_message_join AS cmj
            JOIN message AS m ON cmj.message_id = m.ROWID
            INNER JOIN chat AS c ON cmj.chat_id = c.ROWID
            GROUP BY cmj.chat_id
            ORDER BY MAX(m.date) DESC;
        """)
        chats = cursor.fetchall()
        chats = [chat for chat in chats if chat[1] or chat[2]]
        cursor.close()
        return chats

    def load_contacts(self) -> Dict[str, str]:
        try:
            with open("contacts.json", "r") as f:
                return json.load(f)
        except FileNotFoundError:
            return {}

    def read_messages(self, chat_id: int, self_number='Jack', human_readable_date=True) -> List[Dict[str, str]]:
        cursor = self.conn.cursor()
        query = """
        SELECT message.ROWID, message.date, message.text, message.attributedBody, handle.id, message.is_from_me, message.cache_has_attachments 
        FROM message
        LEFT JOIN handle ON message.handle_id = handle.ROWID
        WHERE message.ROWID IN (SELECT message_id FROM chat_message_join WHERE chat_id = ?)
        ORDER BY message.date
        """
        results = cursor.execute(query, (chat_id,)).fetchall()
        
        messages = []
        contacts = self.load_contacts()
        for result in results:
            rowid, date, text, attributed_body, handle_id, is_from_me, cache_has_attachments = result
            phone_number = self_number if is_from_me else contacts.get(handle_id, handle_id)
            
            body = self.extract_message_body(text, attributed_body)
            date = self.format_time(date) if human_readable_date else date
            
            if phone_number:
                messages.append({"date": date, "body": body, "phone_number": phone_number})
        
        cursor.close()
        return messages

    def extract_message_body(self, text: str, attributed_body: bytes) -> str:
        if text:
            return text
        
        if attributed_body:
            decoded_body = attributed_body.split(b"NSString")[1]
            text = decoded_body[5:]
            if text[0] == 129:
                length = int.from_bytes(text[1:3], "little") 
                text = text[3:length+3]
            else:
                length = text[0]
                text = text[1:length+1]
            return text.decode()
        
        return ""

    def format_time(self, time_sent: int) -> str:
        apple_epoch = datetime.datetime(2001, 1, 1)
        time_sent_seconds = time_sent / 1_000_000_000
        time_sent_datetime = apple_epoch + datetime.timedelta(seconds=time_sent_seconds)
        return time_sent_datetime.strftime('%Y-%m-%d %H:%M')
"""

##
##
File Name: button.py
#
"""
import tkinter as tk

class ToolbarButton(tk.Button):
    def __init__(self, parent, text, command, *args, **kwargs):
        super().__init__(parent, text=text, command=command, *args, **kwargs)
        self.pack(side=tk.LEFT, padx=2, pady=2)
"""

##
##
File Name: toolbar.py
#
"""
import tkinter as tk
from .button import ToolbarButton

class Toolbar(tk.Frame):
    def __init__(self, parent, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.pack(side=tk.TOP, fill=tk.X)

    def add_button(self, text, command):
        button = ToolbarButton(self, text=text, command=command)
        return button
"""

##
##
File Name: gui.py
#
"""
import tkinter as tk
from tkinter import messagebox, filedialog
from pathlib import Path
import zipfile
from text_collector import TextCollector
from components.toolbar import Toolbar

class iMessageViewer(tk.Tk):
    def __init__(self, db_path):
        super().__init__()
        self.title('Hermes iMessage Viewer')
        self.geometry('1000x600')

        self.collector = TextCollector(db_path)
        if not self.collector.conn:
            messagebox.showerror("Database Error", "Cannot connect to the iMessage database.")
            self.destroy()
            return

        self.chats = []
        self.create_widgets()

    def create_widgets(self):
        # Top Bar
        self.top_bar = tk.Frame(self)
        self.top_bar.pack(fill=tk.X)

        self.connect_button = tk.Button(self.top_bar, text="Connect", command=self.load_chats)
        self.connect_button.pack(side=tk.LEFT)

        self.search_bar = tk.Entry(self.top_bar)
        self.search_bar.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.search_bar.bind("<KeyRelease>", self.filter_chats)

        # Main Content
        self.paned_window = tk.PanedWindow(self, orient=tk.HORIZONTAL)
        self.paned_window.pack(fill=tk.BOTH, expand=1)

        self.chat_list = tk.Listbox(self, width=50, height=2)
        self.chat_list.bind('<<ListboxSelect>>', self.display_messages)
        self.paned_window.add(self.chat_list)

        self.message_text = tk.Text(self, wrap=tk.WORD)
        self.paned_window.add(self.message_text)

        self.export_button = tk.Button(self.top_bar, text="Export", command=self.export_conversation)
        self.export_button.pack(side=tk.LEFT)

        # Configure Listbox for easier selection
        self.chat_list.configure(exportselection=False)
        self.create_toolbar()

    def create_toolbar(self):
        toolbar = Toolbar(self)

        toolbar.add_button("Export All", self.export_all_conversations)
        toolbar.add_button("Export My Texts", self.export_my_texts)

    def export_all_conversations(self):
        zip_path = filedialog.asksaveasfilename(defaultextension=".zip", initialfile="all_conversations.zip")
        if zip_path:
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for chat_id, _, _ in self.chats:
                    messages = self.collector.read_messages(chat_id)
                    export_text = self.format_messages_for_export(messages)
                    zipf.writestr(f"{chat_id}.txt", export_text)
            messagebox.showinfo("Conversations Exported", f"All conversations exported to {zip_path}")

    def export_my_texts(self):
        zip_path = filedialog.asksaveasfilename(defaultextension=".zip", initialfile="my_texts.zip")
        if zip_path:
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for chat_id, _, _ in self.chats:
                    messages = self.collector.read_messages(chat_id)
                    my_texts = [msg for msg in messages if msg['phone_number'] == 'Jack']
                    export_text = self.format_messages_for_export(my_texts)
                    zipf.writestr(f"{chat_id}_my_texts.txt", export_text)
            messagebox.showinfo("My Texts Exported", f"All your texts exported to {zip_path}")

    def export_conversation(self):
        selection = self.chat_list.curselection()
        if not selection:
            return

        index = selection[0]
        chat_id, chat_name, chat_identifier = self.chats[index]
        messages = self.collector.read_messages(chat_id)

        export_text = self.format_messages_for_export(messages)

        default_filename = f"{chat_name or chat_identifier}.txt"
        file_path = filedialog.asksaveasfilename(defaultextension=".txt", initialfile=default_filename)
        if file_path:
            self.save_messages_to_file(file_path, export_text)
            messagebox.showinfo("Conversation Exported", f"Conversation saved to {file_path}")

    def format_messages_for_export(self, messages):
        export_text = ""
        for message in messages:
            sender = message['phone_number']
            content = message['body']
            time_sent = message['date']
            export_text += f"{sender}: {content} ({time_sent})\n"
        return export_text

    def save_messages_to_file(self, file_path, export_text):
        with open(file_path, 'w') as f:
            f.write(export_text)

    def filter_chats(self, event=None):
        """Filters the chat list based on search input."""
        search_term = self.search_bar.get().lower()
        self.chat_list.delete(0, tk.END)
        
        for _, chat_name, chat_identifier in self.chats:
            display_name = f'{chat_identifier}' if chat_name == "" else f'{chat_name}'
            if chat_name is None and chat_identifier is None:
                continue
            if search_term == "" or search_term in display_name.lower():
                self.chat_list.insert(tk.END, display_name)

    def load_chats(self):
        """Loads chats ordered by recent activity and updates listbox with contact name or chat ID."""
        self.chat_list.delete(0, tk.END)  
        self.chats = self.collector.get_all_chat_ids_with_labels()
        self.filter_chats()  # Apply filtering after loading

    def display_messages(self, event):
        selection = self.chat_list.curselection()
        if not selection:
            return

        index = selection[0]
        chat_id, chat_name, chat_identifier = self.chats[index]
        messages = self.collector.read_messages(chat_id)

        self.message_text.configure(state=tk.NORMAL)  # Make the Text widget editable
        self.message_text.delete('1.0', tk.END)

        # Improved formatting with tags for sender and time
        if chat_name == "":
            self.message_text.insert(tk.END, f"chat id: {chat_identifier}\n")  
        else:
            self.message_text.insert(tk.END, f"{chat_name}\n")  
        for message in messages:
            sender = message['phone_number']
            content = message['body']
            time_sent = message['date']

            # Add sender with bold tag
            self.message_text.insert(tk.END, f"{sender}: ", 'sender')  
            
            # Add content 
            self.message_text.insert(tk.END, f"{content}\n", 'body')

            # Add time sent with gray tag on a new line
            self.message_text.insert(tk.END, f"\t{time_sent}\n", 'time')  

        self.message_text.configure(state=tk.DISABLED)  # Make the Text widget read-only

        # Define tags for styling 
        self.message_text.tag_config('body', font=('Arial', 15, 'bold'))
        self.message_text.tag_config('time', foreground='gray', font=('Arial', 10, 'italic'))

    def save_conversation(self, chat_name, messages):
        """Saves the conversation to a .txt file with a timestamp to differentiate versions."""
        from datetime import datetime
        timestamp = datetime.now().strftime("%m-%Y_%H-M")
        filename = f"{chat_name}_{timestamp}.dump.txt"
        with open(filename, 'w') as f:
            f.writelines(messages)
        messagebox.showinfo("Conversation Saved", f"Conversation saved to {filename}")

if __name__ == "__main__":
    db_path = Path.home() / 'Library' / 'Messages' / 'chat.db'
    app = iMessageViewer(db_path)
    app.mainloop()
"""

##

##
Full Directory Tree
#
/Users/jckwind/Documents/Hermes
├── Hermes_05-24_17-34.dump.txt
├── README.md
├── contacts.json
├── requirements.txt
├── schema.txt
└── src
    ├── components
    │   ├── button.py
    │   └── toolbar.py
    ├── gui.py
    └── text_collector.py

3 directories, 9 files

==
